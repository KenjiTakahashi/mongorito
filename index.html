<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Mongorito - MongoDB ODM for Node.js</title>
	<link href="http://twitter.github.com/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">
	<link href="stylesheets/bootstrap.min.css" rel="stylesheet">
</head>
<body onload="prettyPrint()">
	<div class="container">
		<h1>Mongorito</h1>
		<a class="btn btn-primary" href="http://search.npmjs.org/#/mongorito">NPM</a>
		<a class="btn btn-info" href="https://github.com/vdemedes/mongorito">Github</a>
		<a class="btn" href="http://twitter.com/vdemedes">Twitter</a>
		<hr>
		<p>
			Easy-to-work-with MongoDB ODM for Node.js. Built-in caching with <b>memcached</b>. Clean codebase.
		</p>
		<h2>Features</h2>
		<ul>
			<li>Define models, and operate with them with human-understandable methods, forget about documentation</li>
			<li>Built-in caching, using <a href="https://github.com/vdemedes/memcacher">Memcacher</a></li>
			<li>Based on <a href="https://github.com/marcello3d/node-mongolian">Mongolian</a></li>
			<li>Super-fast, lightweight, all codebase is in one file</li>
			<li>Covered by tests</li>
			<li>Active development</li>
		</ul>
		<h2>Installation</h2>
		<code>npm install mongorito</code>
		<h2>Usage</h2>
		<pre class="prettyprint linenums">
Mongorito = require 'mongorito'

Mongorito.connect 'database', ['127.0.0.1:27017'], 'user', 'password'
Mongorito.cache ['127.0.0.1:11211'] # optional, allows automatic, smart caching. It is just one line to enable it!

class Post
    constructor: ->
        super 'posts' # telling our collection name

Post = Mongorito.bake Post # Now, we are ready to go!

post = new Post
post.title = 'Very interesting article.'
post.content = 'Really, really, exciting.'
post.save (err) ->
    # saved!

    post.title = 'Edited title!'
    post.save (err) ->
        # updated!

        post.remove ->
            # removed!

Post.find { title : 'Some title!' }, (err, posts) ->
    for post in posts
        # post is an instance of Post model, so you can perform usual methods on it
        post.remove ->
</pre>
		<h2>Examples</h2>
		<p>You can find an up-to-date collection of examples in Mongorito's Github repository, in the <a href="https://github.com/vdemedes/mongorito/tree/master/examples">examples</a> folder.</p>
		<div class="docs clearfix clear">
			<h2 style="float:left;position:relative;top:-25px;margin-right:20px">Documentation</h2>
			<div class="btn-group">
				<a href="#connecting" class="btn">Connecting</a>
				<a href="#defining" class="btn">Defining</a>
				<a href="#finding" class="btn">Finding</a>
				<a href="#creating" class="btn">Creating</a>
				<a href="#updating" class="btn">Updating</a>
				<a href="#removing" class="btn">Removing</a>
				<a href="#hooking" class="btn">Hooking</a>
				<a href="#validating" class="btn">Validating</a>
				<a href="#caching" class="btn">Caching</a>
			</div>
		</div>
		<a name="connecting" href="#connecting"><h2>Connecting</h2></a>
		<p>This is how you can connect to one or many MongoDB databases:</p>
		<pre class="prettyprint linenums">
Mongorito = require 'Mongorito'

Mongorito.connect 'databaseName', ['127.0.0.1:27017'], 'user', 'password' # array can contain uris to multiple servers
</pre>
		<a name="defining" href="#defining"><h2>Defining</h2></a>
		<p>You can define model this way:</p>
		<pre class="prettyprint linenums">
class Post
	constructor: ->
		super 'posts' # telling Mongorito name of the collection
	
Post = Mongorito.bake Post # it would not be interesting without dark magic, right?
</pre>
		<a name="finding" href="#finding"><h2>Finding</h2></a>
		<p>Let's take a walk and see how can you find documents, sort, limit and skip some of them. First, let's just find some documents without additional requirements:</p>
		<pre class="prettyprint linenums">
Post.find (err, posts) ->
	# posts is an array of all documents in the "posts" collection
</pre>
		<p>Now, let's add some criteria:</p>
		<pre class="prettyprint linenums">
Post.find title: 'I love Apple', (err, posts) ->
	# posts is an array of all documents, who have "I love Apple" title
</pre>
		<p>What if we want to sort documents by their creation date?</p>
		<pre class="prettyprint linenums">
Post.findWithOrder _id: -1, (err, posts) ->
	# posts is an array of all documents, sorted by _id
</pre>
		<p>Of course, sometimes we have to limit our results and do some pagination:</p>
		<pre class="prettyprint linenums">
Post.findWithLimit 5, 2, (err, posts) ->
	# skipping first 2 documents, and getting only 5

Post.findWithLimit title: 'I love Apple', 5, 2, (err, posts) ->
	# skipping first 2, getting only 5 documents who have title "I love Apple"
</pre>
		<p>And sometimes we have to order and limit:</p>
		<pre class="prettyprint linenums">
Post.findWithOrderAndLimit { author: 'Steve' }, { _id: -1 }, 5, 2, (err, posts) ->
	# finding documents with author "Steve", sorting them by _id, skipping first 2 and limiting result to 5 records
</pre>
		<p>Forgot to mention, that in all these examples, <b>posts</b> array contains Mongorito models, so you can do usual operations with them. Keep reading ;-)</p>
		<a name="creating" href="#creating"><h2>Creating</h2></a>
		<p>Let's create some new documents in our <b>posts</b> collection:</p>
		<pre class="prettyprint linenums">
post = new Post
post.title = 'I love Apple'
post.author = 'Steve'
post.body = 'Who does not like Apple?'
post.save ->
	# post saved
</pre>
		<p>Notice, that you don't need to declare fields in the model, Mongorito automatically detects what belongs to you, and what is not.</p>
		<a name="updating" href="#updating"><h2>Updating</h2></a>
		<p>Updating the document is as easy as creating it:</p>
		<pre class="prettyprint linenums">
Post.find title: 'I love Apple', (err, posts) ->
	post = posts[0] # let's take the first one
	post.title = 'I love Apple more than Microsoft'
	post.save ->
		# post updated
</pre>
		<a name="removing" href="#removing"><h2>Removing</h2></a>
		<pre class="prettyprint linenums">
Post.find title: 'I love Apple', (err, posts) ->
	posts[0].remove ->
		# post removed
</pre>
		<a name="hooking" href="#hooking"><h2>Hooking</h2></a>
		<p>Mongorito provides you with such hooks as: beforeCreate, afterCreate, aroundCreate, beforeUpdate, afterUpdate, aroundUpdate. Let me know if you need more, I'll add them.</p>
		<pre class="prettyprint linenums">
class Post
	constructor: ->
		super 'posts'
	
	beforeCreate: -> # before creating
	
	afterCreate: -> # after creating
	
	aroundCreate: -> # before and after creating(double execution)
	
	beforeUpdate: -> # before updating
	
	afterUpdate: -> # after updating
	
	aroundUpdate: -> # before and after updating

Post = Mongorito.bake Post
</pre>
		<a name="validating" href="#validating"><h2>Validating</h2></a>
		<p>Mongorito supports only <b>async</b> validations, sorry.</p>
		<pre class="prettyprint linenums">
class Tweet
	constructor: ->
		super 'tweets'

	validateBody: (callback) -> # you should pass false, if invalid and true, if valid
		if @body.length >= 140
			callback false
		else
			callback true

Tweet = Mongorito.bake Tweet

tweet = new Tweet
tweet.body = 'I want to be super-super-super-super long! Reallly, reallly, long!!!! In fact, I am VEEERY long! You\'ve never seen such a looooooong tweeeeeet!'
tweet.save (err, results) ->
	# results will be ['body'], because body field did not pass validation
</pre>
		<a name="caching" href="#caching"><h2>Caching</h2></a>
		<p>Mongorito offers built-in caching via <a href="https://github.com/vdemedes/Memcacher">Memcacher</a>, which adds tags functionality to memcached, without modifying it. To force Mongorito to cache documents automatically, you need to write just one line:</p>
		<pre class="prettyprint linenums">
Mongorito.cache ['127.0.0.1:11211'] # array of memcached servers
</pre>
	</div>
	<script src="scripts/prettify.js"></script>
</body>
</html>