// Generated by CoffeeScript 1.3.1
var Client, Model, Mongorito, async, inflect, mongolian;

mongolian = require('mongolian');

async = require('async');

inflect = require('i');

Client = void 0;

String.prototype.replaceAt = function(index, char) {
  return this.substr(0, index) + char + this.substr(index + char.length);
};

var __hasProp = {}.hasOwnProperty,
  extendsClass = function(child, parent) {
	for (var key in parent) {
		if (__hasProp.call(parent, key)) child[key] = parent[key]; 
	}
	function ctor() {
		this.constructor = child;
		for(var key in child.prototype) {
			var newKey = inflect.camelize(key);
			this[newKey.replaceAt(0, String.fromCharCode(32 + newKey.charCodeAt(0)))] = child.prototype[key];
		}
	}
	ctor.prototype = parent.prototype;
	child.prototype = new ctor;
	child.__super__ = parent.prototype;
	return child;
};


Mongorito = (function() {

  Mongorito.name = 'Mongorito';

  function Mongorito() {}

  Mongorito.disconnect = function() {
    return Client.close();
  };

  Mongorito.connect = function(servers) {
    if (servers == null) {
      servers = [];
    }
    Client = new mongolian(servers[0]);
    return Client.log = {
      debug: function() {},
      info: function() {},
      warn: function() {},
      error: function() {}
    };
  };

  Mongorito.bake = function(model) {
    var scope, scopes;
    extendsClass(model, Model);
    model.prototype.collectionName = model.collectionName = model.prototype.collectionName || inflect.pluralize(model.name.toLowerCase());
    if (model.prototype.scopes) {
      scopes = [];
      for (scope in model.prototype.scopes) {
        scopes.push(scope);
      }
      async.forEach(scopes, function(scope, nextScope) {
        model[scope] = function(callback) {
          return model.find(model.prototype.scopes[scope], callback);
        };
        return nextScope();
      }, function() {});
    }
    model.model = model;
    return model;
  };

  return Mongorito;

})();

Model = (function() {

  Model.name = 'Model';

  function Model() {}

  Model.prototype.fields = function() {
    var field, fields, notFields;
    notFields = ['constructor', 'save', 'collectionName', 'create', 'fields', 'update', 'remove', 'beforeCreate', 'aroundCreate', 'afterCreate', 'beforeUpdate', 'aroundUpdate', 'afterUpdate', 'old', 'callMethod', 'fill', 'scopes', 'keys', 'model'];
    fields = {};
    for (field in this) {
      if (-1 === notFields.indexOf(field)) {
        fields[field] = this[field];
      }
    }
    return fields;
  };

  Model.bakeModelsFromItems = function(items, _model) {
    var field, item, model, models, _i, _len;
    models = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      item._id = item._id.toString();
      model = new _model;
      model.collectionName = _model.collectionName;
      model.old = {};
      model.model = _model;
      for (field in item) {
        model.old[field] = model[field] = item[field];
      }
      models.push(model);
    }
    return models;
  };

  Model.find = function(options, callback) {
    var query, that;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    } else {
      if (options.callback) {
        callback = options.callback;
        delete options.callback;
      }
    }
    that = this;
    query = function(done) {
      var fields, notFields, property, request;
      fields = {};
      notFields = ['limit', 'skip', 'sort'];
      for (property in options) {
        if (options.hasOwnProperty(property) && notFields.indexOf(property) === -1) {
          fields[property] = options[property];
        }
      }
      request = Client.collection(that.collectionName).find(fields);
      if (options.limit) {
        request = request.limit(options.limit);
      }
      if (options.skip) {
        request = request.skip(options.skip);
      }
      if (options.sort) {
        request = request.sort(options.sort);
      }
      return request.toArray(function(err, items) {
        var item, _i, _len;
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          item._id = item._id.toString();
        }
        return done(err, items);
      });
    };
    return query(function(err, items) {
      var models;
      models = that.bakeModelsFromItems(items, that.model);
      return callback(err, models);
    });
  };

  Model.prototype.fill = function(fields) {
    var key, _results;
    if (fields == null) {
      fields = {};
    }
    _results = [];
    for (key in fields) {
      if (-1 < this.keys.indexOf(key)) {
        _results.push(this[key] = fields[key]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Model.prototype.callMethod = function(method) {
    method = this[method] || this[inflect.underscore(method)];
    if (method) {
      return method();
    }
  };

  Model.prototype.save = function(callback) {
    var field, fields, keys, that;
    that = this;
    this.old = fields = this.fields();
    keys = [];
    for (field in fields) {
      keys.push(field);
    }
    return async.filter(keys, function(key, nextKey) {
      var validationMethod;
      validationMethod = that["validate" + (inflect.camelize(key))] || that["validate_" + (inflect.underscore(key))];
      if (validationMethod) {
        return validationMethod(function(valid) {
          return nextKey(!valid);
        });
      } else {
        return nextKey(false);
      }
    }, function(results) {
      var performOperation;
      if (results.length > 0) {
        return callback(true, results);
      }
      performOperation = function() {
        if (fields._id) {
          return that.update(callback, true);
        } else {
          return that.create(callback, true);
        }
      };
      return performOperation();
    });
  };

  Model.prototype.create = function(callback, fromSave) {
    var object, that;
    if (fromSave == null) {
      fromSave = false;
    }
    object = this.fields();
    this.callMethod('beforeCreate');
    this.callMethod('aroundCreate');
    that = this;
    return Client.collection(this.collectionName).insert(object, function(err, result) {
      result._id = result._id.toString();
      that._id = result._id;
      that.callMethod('aroundCreate');
      that.callMethod('afterCreate');
      if (callback) {
        return callback(err, result);
      }
    });
  };

  Model.prototype.update = function(callback, fromSave) {
    var object, that, _id;
    if (fromSave == null) {
      fromSave = false;
    }
    object = this.fields();
    _id = new mongolian.ObjectId(object._id);
    delete object._id;
    this.callMethod('beforeUpdate');
    this.callMethod('aroundUpdate');
    that = this;
    return Client.collection(this.collectionName).update({
      _id: _id
    }, object, function(err, rowsUpdated) {
      that.callMethod('aroundUpdate');
      that.callMethod('afterUpdate');
      if (callback) {
        return callback(err, rowsUpdated);
      }
    });
  };

  Model.prototype.remove = function(callback) {
    var object, query, that, _id;
    object = this.fields();
    _id = new mongolian.ObjectId(object._id);
    this.callMethod('beforeRemove');
    this.callMethod('aroundRemove');
    that = this;
    query = function() {
      return Client.collection(that.collectionName).remove({
        _id: _id
      }, function(err) {
        that.callMethod('aroundRemove');
        that.callMethod('afterRemove');
        if (callback) {
          return callback(err);
        }
      });
    };
    return query();
  };

  return Model;

})();

module.exports = {
  connect: Mongorito.connect,
  disconnect: Mongorito.disconnect,
  bake: Mongorito.bake
};
